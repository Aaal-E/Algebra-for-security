\documentclass[a4paper]{article}

\usepackage{hyperref}

\title{Assignment 2WF90, Integer Arithmetic, September 2018}
\author{
    Tim With A Lastname\\
    \texttt{0123456}
    \and
    Alex With A Lastname\\
    \texttt{0123456}
    \and
    Anastasiia Bilonizhko\\
    \texttt{1393456}
    \and
    Maarten Visscher\\
    \texttt{0888263}
    \and
    Adrian Stefan Vr\^amulet\\
    \texttt{1284487}
}


%  The document should at least contain:
% – A title page with names, student id’s, assignment title (such as ‘Assignment 2WF90, Integer Arithmetic, September 2018’);
% – Table of contents, division in sections.
% – Where relevant references to literature and the lecture notes. List of references at the end of the document.
% – A mathematical description of how your code works and what your code can do.
% – A description of the limitations of your code.
% – Illustrative examples.
% – Each member’s contribution.



\begin{document}


\maketitle



\begin{abstract}
Optionally an abstract.
\end{abstract}

\section*{Introduction}

\tableofcontents




\section{Run instructions}

% Include an explanation on how to install and run the software on a Windows platform.

% Describe what your approach is: how you represent various objects, how users should input polynomials, etc. Show, by including, for example, screenshots of your program at work, that your set-up works.


\subsection{Run examples}


\section{Code layout}

\subsection{Big integer representation (class BigNumber)}

The representation of big integers is done using an array of normal 32-bit integers.
Each element in the array corresponds to one digit from the original input.
For an original input of length $n$ digits, the element at index $0$ has the least significant digit,
index $n-1$ has the most significant digit, and index $n$ stores the sign of the integer.
If the value at index $n$ is 0, the sign is positive, if the value is $1$, the sign is negative.

As an example, if the input is $-345$, the resulting array is $\{5, 4, 3, 1\}$.
For the input $123$ the resulting array is $\{3, 2, 1, 0\}$.

Book \cite{ant}.

\section{Integer arithmetic}

\subsection{Addition and subtraction (Integer/Adder.java)}

We start with determining whether we need to add the two numbers or whether we need to subtract.
Addition of a positive and a negative number is equivalent to subtraction of two positive numbers.
Addition of two negative numbers is equivalent to addition of two positive numbers, and adjusting the sign of the output
(\cite{ant} page 3, section 1.3.1).
This check is performed first in the function \texttt{add()}.
After checking, the \texttt{do\_add} or \texttt{do\_sub} function is ran.

\subsection{Multiplication}




\subsection{Multiplication by the method of Karatsuba}

\subsection{Division}

The division with remainder implementation is based on [\cite{ant} Algorithm 1.4].
For inputs $x, y$ consisting of words in base $b$ it computes $q, r$ with $x=qy+r$ and $0 \le r < y$.
Prior to running the division algorithm, we first take the absolute values of the inputs.
Using these positive values we run the algorithm.
Afterwards the sign is corrected.

\paragraph{Division with nonnegative integers}
$m$ denotes the number of words in $x$, $n$ denotes the number of words in $y$.

Step 1: $r \gets x$, $k \gets m - n + 1$.

Step 2: \textbf{for} $i = k-1, k-2, \ldots, 0$ \textbf{do:}
$q_i \gets \lfloor r / (b^i y) \rfloor$ and $r \gets r - q_i b^i y$.
For the computation of $q_i$ we use the approximation as explained in [\cite{ant}].
We divide the one or two most significant words in the numerator with the single most significant word in the denominator. The algorithm ensures that the number of words in the numerator will be at most one more than the number of words in the denominator.
The elementary division operation that needs to be performed hereby is with at most two words for the numerator and one word for the denominator.
The approximation is good when the denominator for the approximation is larger or equal than $\frac{1}{2} b$. If that is not the case, we double the original numerator and denominator until we have that approximation denominator is greater than or equal to $\frac{1}{2} b$. (This will not make the denominator overflow, i.e. will not add a one higher most significant word).
Using the approximation for $q_i$ we reduce the remainder by $q_i b^i y$.
If we have $0 \le r < y$ we are good, else we adjust $q_i$ and $r$ accordingly.

Step 3: remove leading zeros.


\paragraph{Sign correction}

For quotient $q$ we have: $q$ is positive $\iff$ ($x$ and $y$ are positive $\lor$ $x$ and $y$ are negative).

For remainder $r$ we have: $r$ is positive $\iff$ $x$ is positive.

\paragraph{Special case $|x|<|y|$}

For cases where $|x|<|y|$ the implementation of the algorithm gives some practical problems because $k$ can become negative.
In these cases the answer is trivially $q=0$ and $r=x$.
Therefore before running the algorithm we check for this special case and return appropriately.

\subsection{Euclid’s Extended Algorithm}


\section{Modular arithmetic}

\subsection{Modular reduction}

\subsection{Addition, subtraction}

\subsection{Multiplication}

\subsection{Modular inversion for a large modulus m}

\section{Discussion}

% Present some examples of different word sizes and radices, and compare elementary operation counts of primary school and Karatsuba methods. Draw a conclusion based on the theory.



\section{Limitations}

% Base > 32-bit?


\section{Contributions}

\paragraph{Code}

Tim and Alex.

\paragraph{Documentation}

Maarten.


\begin{thebibliography}{9}

\bibitem{ant}
  Benne de Weger,
  2WF70 - Algorithmic Algebra and Number Theory,
  2WF90 - Algebra for Security,
  Part 1 - Algorithmic Number Theory,
  version 0.65,
  December 15, 2017

\end{thebibliography}


\end{document}
